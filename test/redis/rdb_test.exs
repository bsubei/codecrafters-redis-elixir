defmodule Redis.RDBTest do
  use ExUnit.Case
  alias Redis.{RDB, KeyValueStore, Value}
  doctest RDB

  describe "decode RDB data" do
    setup do
      # NOTE: because there is only one KeyValueStore in our application, we should reset it to the initial state after every test clause.
      on_exit(fn -> KeyValueStore.clear() end)
    end

    test "given invalid data should error out" do
      {:error, :invalid_header_section} = RDB.decode_rdb("")

      {:error, :invalid_header_section} =
        RDB.decode_rdb("no way will thiswork because, this is just random text")
    end

    test "given a valid empty RDB file" do
      {:ok, %{}} = RDB.decode_rdb(RDB.get_empty_rdb())
    end

    test "given a valid non-empty RDB file" do
      # This string is a base16 encoded RDB file, and only has a single key-value pair: "hi" and "bye". It was generated by running:
      # xxd -p dump.rdb | tr -d '\n'
      base16_rdb =
        "524544495330303039fa0972656469732d76657205352e302e37fa0a72656469732d62697473c040fa056374696d65c2b8764367fa08757365642d6d656dc2f8260c00fa0c616f662d707265616d626c65c000fe00fb01000002686903627965ff11a65bf65e57de23"

      nonempty_rdb = Base.decode16!(base16_rdb, case: :lower)
      expected_kvstore = %{"hi" => Value.init("bye", nil)}
      {:ok, ^expected_kvstore} = RDB.decode_rdb(nonempty_rdb)
    end
  end

  describe "decode RDB header" do
    test "given invalid headers" do
      {:error, :invalid_header_section} = RDB.Header.decode([])
      {:error, :invalid_header_section} = RDB.Header.decode(<<"REDDIT">>)
      {:error, :version_too_old} = RDB.Header.decode(<<"REDIS", "0001">>)
    end

    test "given valid headers" do
      rest = "arbitrary text"
      {:ok, %RDB.Header{version: 9}, ""} = RDB.Header.decode("REDIS0009")

      {:ok, %RDB.Header{version: 20}, ^rest} =
        RDB.Header.decode("REDIS0020#{rest}")
    end
  end
end
