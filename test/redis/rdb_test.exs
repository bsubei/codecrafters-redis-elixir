defmodule Redis.RDBTest do
  use ExUnit.Case
  alias Redis.{RDB, KeyValueStore, Value}
  doctest RDB

  describe "decode RDB data" do
    setup do
      # NOTE: because there is only one KeyValueStore in our application, we should reset it to the initial state after every test clause.
      on_exit(fn -> KeyValueStore.clear() end)
    end

    test "given invalid data should error out" do
      {:error, :invalid_header_section} = RDB.decode_rdb("")

      {:error, :invalid_header_section} =
        RDB.decode_rdb("no way will thiswork because, this is just random text")
    end

    # test "given a valid empty RDB file" do
    #   {:ok, %{}} = RDB.decode_rdb(RDB.get_empty_rdb())
    # end

    # test "given a valid non-empty RDB file" do
    #   # This string is a base16 encoded RDB file, and only has a single key-value pair: "hi" and "bye". It was generated by running:
    #   # xxd -p dump.rdb | tr -d '\n'
    #   base16_rdb =
    #     "524544495330303039fa0972656469732d76657205352e302e37fa0a72656469732d62697473c040fa056374696d65c2b8764367fa08757365642d6d656dc2f8260c00fa0c616f662d707265616d626c65c000fe00fb01000002686903627965ff11a65bf65e57de23"

    #   nonempty_rdb = Base.decode16!(base16_rdb, case: :lower)
    #   expected_kvstore = %{"hi" => Value.init("bye", nil)}
    #   {:ok, ^expected_kvstore} = RDB.decode_rdb(nonempty_rdb)
    # end
  end

  describe "decoding string encoded values" do
    # test "for invalid values" do
    #   # If we're calling decode_length_prefix, the two most-significant bits better not be 0b11
    #   assert RDB.decode_length_prefix(<<0b11::2, 0::6, "whatever">>) ==
    #            {:error, :invalid_length_prefix}
    # end

    # TODO test length encoding using a range of ints to cover every case

    test "for length prefixed strings" do
      # The length of the string is stored in the 6 LSBs.
      {:ok, "ABCDE", "unused"} = RDB.decode_string(<<0b00::2, 5::6, "ABCDEunused">>)

      # The length of the string is stored in the next byte along with the 6 LSBs.
      {:ok, "0123456789", "unused"} = RDB.decode_string(<<0b01::2, 10::14, "0123456789unused">>)

      # The length of the string is stored in the next 4 bytes. Use a big string with more than 2^16 bytes.
      expected_length = 16384

      expected_string =
        Range.new(0, expected_length - 1)
        |> Enum.map(fn i -> rem(i, 10) end)
        |> Enum.reduce("", fn i, acc -> acc <> Integer.to_string(i) end)

      {:ok, ^expected_string, "unused"} =
        RDB.decode_string(
          <<0b10::2, 0::6, expected_length::32, expected_string::binary, "unused">>
        )
    end

    test "for integers as strings" do
    end

    test "for LZF compressed strings" do
      # TODO expected unimplemented error
    end
  end

  describe "decode RDB header" do
    test "given invalid headers" do
      {:error, :invalid_header_section} = RDB.Header.decode([])
      {:error, :invalid_header_section} = RDB.Header.decode(<<"REDDIT">>)
      {:error, :version_too_old} = RDB.Header.decode(<<"REDIS", "0001">>)
    end

    test "given valid headers" do
      rest = "arbitrary text"
      {:ok, %RDB.Header{version: 9}, ""} = RDB.Header.decode("REDIS0009")

      {:ok, %RDB.Header{version: 20}, ^rest} =
        RDB.Header.decode("REDIS0020#{rest}")
    end
  end

  describe "decode RDB Metadata" do
    test "given invalid data" do
      {:error, :missing_metadata_start_byte} = RDB.Metadata.decode([])
      {:error, :missing_metadata_start_byte} = RDB.Metadata.decode(<<"FOOBAR">>)
      # TODO are such tests meaningful?
      {:error, :bad_metadata_key} = RDB.Metadata.decode(<<0xFA>>)
    end

    # test "given a single metadata section" do
    #   # TODO
    #   expected_metadata_sections = [%{}]
    #   input = <<0xFA>>
    #   {:ok, ^expected_metadata_sections, ""} = RDB.Metadata.decode(input)
    # end

    # test "given a multiple metadata sections" do
    #   # TODO
    #   expected_metadata_sections = [%{}]
    #   input = <<0xFA>>
    #   {:ok, ^expected_metadata_sections, ""} = RDB.Metadata.decode(input)
    # end
  end
end
