defmodule Redis.RDBTest do
  use ExUnit.Case
  alias Redis.{RDB, KeyValueStore, Value}
  doctest RDB

  describe "decode RDB data" do
    setup do
      # NOTE: because there is only one KeyValueStore in our application, we should reset it to the initial state after every test clause.
      on_exit(fn -> KeyValueStore.clear() end)
    end

    test "given invalid data should error out" do
      {:error, [:decode_rdb_header_decode, :header_decode_missing_header_byte]} =
        RDB.decode_rdb("")

      {:error, [:decode_rdb_header_decode, :header_decode_missing_header_byte]} =
        RDB.decode_rdb("no way will thiswork because, this is just random text")

      rdb_truncated_after_metadata_section =
        Base.decode16!(
          "524544495330303039fa0972656469732d76657205352e302e37fa0a72656469732d62697473c040fa056374696d65c2b8764367fa08757365642d6d656dc2f8260c00fa0c616f662d707265616d626c65c000",
          case: :lower
        )

      {:error, [:decode_rdb_eof_decode, :eof_decode_missing_eof_byte]} =
        RDB.decode_rdb(rdb_truncated_after_metadata_section)
    end

    test "given a valid empty RDB file" do
      {:ok, [], ""} = RDB.decode_rdb(RDB.get_empty_rdb())
    end

    test "given a valid non-empty RDB file" do
      # This string is a base16 encoded RDB file, and only has one database with a single key-value pair: "hi" and "bye". It was generated by running:
      # xxd -p dump.rdb | tr -d '\n'
      base16_rdb =
        "524544495330303039fa0972656469732d76657205352e302e37fa0a72656469732d62697473c040fa056374696d65c2b8764367fa08757365642d6d656dc2f8260c00fa0c616f662d707265616d626c65c000fe00fb01000002686903627965ff11a65bf65e57de23"

      nonempty_rdb = Base.decode16!(base16_rdb, case: :lower)
      expected_database_sections = [%{"hi" => Value.init("bye")}]
      {:ok, ^expected_database_sections, ""} = RDB.decode_rdb(nonempty_rdb)
    end
  end

  describe "decoding string encoded values" do
    test "for length prefixed strings" do
      # The length of the string is stored in the 6 LSBs.
      {:ok, "ABCDE", "unused"} = RDB.decode_string(<<0b00::2, 5::6, "ABCDEunused">>)

      # The length of the string is stored in the next byte along with the 6 LSBs.
      {:ok, "0123456789", "unused"} = RDB.decode_string(<<0b01::2, 10::14, "0123456789unused">>)

      # The length of the string is stored in the next 4 bytes. Use a big string with more than 2^16 bytes.
      expected_length = 16384

      expected_string =
        Range.new(0, expected_length - 1)
        |> Enum.map(fn i -> rem(i, 10) end)
        |> Enum.reduce("", fn i, acc -> acc <> Integer.to_string(i) end)

      {:ok, ^expected_string, "unused"} =
        RDB.decode_string(
          <<0b10::2, 0::6, expected_length::integer-32-little, expected_string::binary, "unused">>
        )
    end

    test "for integers as strings" do
      # 8-bit integer
      input = <<0b11::2, 0::6, 0x40::8, "rest">>
      {:ok, "64", "rest"} = RDB.decode_string(input)
      # 16-bit integer
      input = <<0b11::2, 1::6, 42::integer-16-little, "rest">>
      {:ok, "42", "rest"} = RDB.decode_string(input)
      input = <<0b11::2, 1::6, 15003::integer-16-little, "rest">>
      {:ok, "15003", "rest"} = RDB.decode_string(input)
      # 32-bit integer
      input = <<0b11::2, 2::6, 5_125_120::integer-32-little, "rest">>
      {:ok, "5125120", "rest"} = RDB.decode_string(input)
    end

    test "for LZF compressed strings" do
      input = <<0b11::2, 3::6, "whatever doesn't matter">>
      {:error, [:decode_string_unimplemented_lzf_string]} = RDB.decode_string(input)
    end
  end

  describe "decode RDB header" do
    test "given invalid headers" do
      {:error, [:header_decode_missing_header_byte]} = RDB.Header.decode([])
      {:error, [:header_decode_missing_header_byte]} = RDB.Header.decode(<<"REDDIT">>)

      {:error, [:header_decode_init, :header_init_version_too_old]} =
        RDB.Header.decode(<<"REDIS", "0001">>)
    end

    test "given valid headers" do
      rest = "arbitrary text"
      {:ok, %RDB.Header{version: 9}, ""} = RDB.Header.decode("REDIS0009")

      {:ok, %RDB.Header{version: 20}, ^rest} =
        RDB.Header.decode("REDIS0020#{rest}")
    end
  end

  describe "decode RDB Metadata" do
    test "given invalid data" do
      {:error,
       [:metadata_decode_pair, :decode_pair_bad_metadata_key, :decode_string_nothing_to_decode]} =
        RDB.Metadata.decode(<<0xFA>>)

      {:error,
       [:metadata_decode_pair, :decode_pair_bad_metadata_value, :decode_string_nothing_to_decode]} =
        RDB.Metadata.decode(<<0xFA, 0x04, "toad">>)
    end

    test "given a single metadata section" do
      expected_metadata_sections = %{"toad" => "chicken"}
      input = <<0xFA, 0x04, "toad", 0x07, "chicken", "unused">>
      {:ok, ^expected_metadata_sections, "unused"} = RDB.Metadata.decode(input)
    end

    test "given a multiple metadata sections" do
      # First section: "redis-ver" and "5.0.7"
      # Second section: "redis-bits" and "64" as an 8-bit integer.
      # Third section: "ctime" and a unix timestamp as a 64 bit integer.
      bytes =
        Base.decode16!("FA0972656469732D76657205352E302E37") <>
          Base.decode16!("FA0A72656469732D62697473C040") <>
          Base.decode16!("FA056374696D65C2B8764367") <>
          "rest"

      expected_metadata_sections = %{
        "redis-ver" => "5.0.7",
        "redis-bits" => "64",
        "ctime" => "1732474552"
      }

      {:ok, ^expected_metadata_sections, "rest"} = RDB.Metadata.decode(bytes)
    end
  end

  describe "decode RDB Database" do
    test "given invalid data" do
      {:error, [:database_decode_decode_subsection, :decode_subsection_missing_db_index]} =
        RDB.Database.decode(<<0xFE>>)

      {:error,
       [
         :database_decode_decode_subsection,
         :decode_subsection_decode_resize_db,
         :invalid_resizedb
       ]} =
        RDB.Database.decode(<<0xFE, 0x00>>)

      {:error,
       [
         :database_decode_decode_subsection,
         :decode_subsection_decode_resize_db,
         :decode_resize_db_invalid_num_total_entries,
         :decode_int_invalid_length_encoded_int
       ]} = RDB.Database.decode(<<0xFE, 0x00, 0xFB>>)

      # This is almost correct, but the "number of expiry" terms in the resizedb field is 0, and because we actually have 1 expiry entry, the validation errors out.
      bytes = Base.decode16!("fe00fb0100fdd20296490002686903627965ff", case: :lower) <> "rest"

      {:error,
       [
         :database_decode_decode_subsection,
         :decode_subsection_validate_entries,
         :validate_entries_bad_num_expiry
       ]} = RDB.Database.decode(bytes)
    end

    test "given a single empty database section" do
      bytes = Base.decode16!("fe00fb0000ff", case: :lower) <> "rest"
      expected_database_sections = [%{}]
      {:ok, ^expected_database_sections, <<0xFF, "rest">>} = RDB.Database.decode(bytes)
    end

    test "given a single nonempty database section" do
      bytes = Base.decode16!("fe00fb01000002686903627965ff", case: :lower) <> "rest"
      expected_database_sections = [%{"hi" => Redis.Value.init("bye")}]
      {:ok, ^expected_database_sections, <<0xFF, "rest">>} = RDB.Database.decode(bytes)

      # Same thing but with an expiry term in seconds.
      bytes = Base.decode16!("fe00fb0101fdd20296490002686903627965ff", case: :lower) <> "rest"
      timestamp_s = 1_234_567_890
      expected_database_sections = [%{"hi" => Redis.Value.init("bye", timestamp_s * 1000)}]
      {:ok, ^expected_database_sections, <<0xFF, "rest">>} = RDB.Database.decode(bytes)
    end

    test "given a multiple database sections with some empty ones also" do
      # Test multiple database sections with gaps. e.g. 2 databases with db indices 5 and 22 (should have 23 databases in the result, with only two populated).
      # Also, the sections are re-ordered based on their database selector index, not the order in which the bytes come in necessarily.

      # Has selector index 0 and contains %{"hi" => "bye"}.
      first_section = Base.decode16!("fe00fb01000002686903627965", case: :lower)
      # Has selector index 3 and contains %{"hit" => "byet"}
      fourth_section = Base.decode16!("fe03fb010000036869740462796574", case: :lower)
      # Has selector index 2 and contains %{"B" => "S"}.
      second_section = Base.decode16!("fe02fb01000001420153", case: :lower)

      bytes = first_section <> fourth_section <> second_section <> <<0xFF>> <> "rest"

      # We expect there to be four databases (index 1 is a padded empty one).
      expected_database_sections = [
        %{"hi" => Redis.Value.init("bye")},
        %{},
        %{"B" => Redis.Value.init("S")},
        %{"hit" => Redis.Value.init("byet")}
      ]

      {:ok, ^expected_database_sections, <<0xFF, "rest">>} = RDB.Database.decode(bytes)
    end
  end
end
